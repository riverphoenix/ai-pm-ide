import { invoke } from '@tauri-apps/api/core';
import { Project, Conversation, Message, Settings, SettingsUpdate, TokenUsage, TokenUsageAggregate, ContextDocument, FrameworkOutput, Folder, SearchResult, CommandHistoryEntry, CommandResult, FrameworkDefinition, FrameworkCategory, SavedPrompt, PromptVariable, ImportPreview, ImportResult, BatchExportResult, ConflictAction, Workflow, WorkflowRun, WorkflowRunStep, ProjectInsight, CommitInfo, JiraProject, JiraExportResult, NotionPage, NotionExportResult } from './types';

interface FrameworkDefRow {
  id: string;
  category: string;
  name: string;
  description: string;
  icon: string;
  example_output: string;
  system_prompt: string;
  guiding_questions: string;
  supports_visuals: boolean;
  visual_instructions: string | null;
  is_builtin: boolean;
  sort_order: number;
  created_at: number;
  updated_at: number;
}

interface FrameworkCategoryRow {
  id: string;
  name: string;
  description: string;
  icon: string;
  is_builtin: boolean;
  sort_order: number;
  created_at: number;
  updated_at: number;
}

function parseFrameworkDef(row: FrameworkDefRow): FrameworkDefinition {
  return {
    ...row,
    guiding_questions: JSON.parse(row.guiding_questions || '[]'),
    visual_instructions: row.visual_instructions || undefined,
  };
}

function parseCategoryRow(row: FrameworkCategoryRow): Omit<FrameworkCategory, 'frameworks'> {
  return row;
}

export const projectsAPI = {
  async create(name: string, description?: string): Promise<Project> {
    return await invoke('create_project', { name, description });
  },

  async list(): Promise<Project[]> {
    return await invoke('list_projects');
  },

  async get(id: string): Promise<Project | null> {
    return await invoke('get_project', { id });
  },

  async update(id: string, name: string, description?: string): Promise<Project> {
    return await invoke('update_project', { id, name, description });
  },

  async delete(id: string): Promise<void> {
    return await invoke('delete_project', { id });
  },
};

export const conversationsAPI = {
  async create(
    projectId: string,
    title?: string,
    model: string = 'gpt-5'
  ): Promise<Conversation> {
    return await invoke('create_conversation', {
      projectId,
      title,
      model,
    });
  },

  async list(projectId: string): Promise<Conversation[]> {
    return await invoke('list_conversations', { projectId });
  },

  async get(id: string): Promise<Conversation | null> {
    return await invoke('get_conversation', { id });
  },

  async updateStats(
    id: string,
    tokens: number,
    cost: number
  ): Promise<void> {
    return await invoke('update_conversation_stats', {
      id,
      tokens,
      cost,
    });
  },

  async delete(id: string): Promise<void> {
    return await invoke('delete_conversation', { id });
  },
};

export const messagesAPI = {
  async add(
    conversationId: string,
    role: 'user' | 'assistant',
    content: string,
    tokens: number = 0
  ): Promise<Message> {
    return await invoke('add_message', {
      conversationId,
      role,
      content,
      tokens,
    });
  },

  async list(conversationId: string): Promise<Message[]> {
    return await invoke('get_messages', { conversationId });
  },
};

export const settingsAPI = {
  async get(): Promise<Settings> {
    return await invoke('get_settings');
  },

  async update(settings: SettingsUpdate): Promise<Settings> {
    return await invoke('update_settings', { settings });
  },

  async getDecryptedApiKey(): Promise<string | null> {
    return await invoke('get_decrypted_api_key');
  },

  async deleteApiKey(): Promise<void> {
    return await invoke('delete_api_key');
  },
};

export const tokenUsageAPI = {
  async record(
    conversationId: string,
    model: string,
    inputTokens: number,
    outputTokens: number,
    cost: number
  ): Promise<string> {
    return await invoke('record_token_usage', {
      conversationId,
      model,
      inputTokens,
      outputTokens,
      cost,
    });
  },

  async getByDateRange(
    startDate: string,
    endDate: string,
    viewType: 'daily' | 'monthly'
  ): Promise<TokenUsageAggregate[]> {
    return await invoke('get_token_usage_by_date_range', {
      startDate,
      endDate,
      viewType,
    });
  },

  async getAll(): Promise<TokenUsage[]> {
    return await invoke('get_all_token_usage');
  },
};

// Python sidecar API (direct HTTP calls)
const SIDECAR_URL = 'http://127.0.0.1:8000';

export const modelsAPI = {
  async list(apiKey: string): Promise<string[]> {
    try {
      const response = await fetch(`${SIDECAR_URL}/models?api_key=${encodeURIComponent(apiKey)}`);
      if (!response.ok) {
        throw new Error(`Failed to fetch models: ${response.statusText}`);
      }
      const data = await response.json();
      return data.models || [];
    } catch (error) {
      console.error('Error fetching models:', error);
      // Return Frontier models as fallback (GPT-5 generation)
      return [
        'gpt-5',
        'gpt-5-mini',
        'gpt-5-nano',
      ];
    }
  },
};

export const foldersAPI = {
  async create(projectId: string, name: string, parentId?: string, color?: string): Promise<Folder> {
    return await invoke('create_folder', { projectId, name, parentId, color });
  },

  async list(projectId: string): Promise<Folder[]> {
    return await invoke('list_folders', { projectId });
  },

  async get(id: string): Promise<Folder | null> {
    return await invoke('get_folder', { id });
  },

  async update(id: string, name?: string, parentId?: string | null, color?: string): Promise<Folder> {
    return await invoke('update_folder', {
      id,
      name,
      parentId: parentId === null ? '__null__' : parentId,
      color,
    });
  },

  async delete(id: string): Promise<void> {
    return await invoke('delete_folder', { id });
  },

  async moveItem(itemId: string, itemType: 'context_doc' | 'framework_output', folderId: string | null): Promise<void> {
    return await invoke('move_item_to_folder', { itemId, itemType, folderId });
  },

  async searchItems(projectId: string, query: string): Promise<SearchResult[]> {
    return await invoke('search_project_items', { projectId, query });
  },

  async toggleItemFavorite(itemId: string, itemType: 'context_doc' | 'framework_output', isFavorite: boolean): Promise<void> {
    return await invoke('toggle_item_favorite', { itemId, itemType, isFavorite });
  },

  async setFolderColor(id: string, color: string | null): Promise<void> {
    return await invoke('set_folder_color', { id, color });
  },
};

export const terminalAPI = {
  async execute(projectId: string, command: string): Promise<CommandResult> {
    return await invoke('execute_shell_command', { projectId, command });
  },

  async getHistory(projectId: string, limit?: number): Promise<CommandHistoryEntry[]> {
    return await invoke('get_command_history', { projectId, limit: limit || 50 });
  },
};

export const contextDocumentsAPI = {
  async create(
    projectId: string,
    name: string,
    docType: 'pdf' | 'url' | 'google_doc' | 'text',
    content: string,
    url?: string,
    isGlobal: boolean = false
  ): Promise<ContextDocument> {
    return await invoke('create_context_document', {
      projectId,
      name,
      docType,
      content,
      url,
      isGlobal
    });
  },

  async list(projectId: string): Promise<ContextDocument[]> {
    return await invoke('list_context_documents', { projectId });
  },

  async get(id: string): Promise<ContextDocument | null> {
    return await invoke('get_context_document', { id });
  },

  async update(id: string, name: string, isGlobal: boolean): Promise<ContextDocument> {
    return await invoke('update_context_document', {
      id,
      name,
      isGlobal
    });
  },

  async delete(id: string): Promise<void> {
    return await invoke('delete_context_document', { id });
  }
};

export const frameworkCategoriesAPI = {
  async list(): Promise<Omit<FrameworkCategory, 'frameworks'>[]> {
    const rows: FrameworkCategoryRow[] = await invoke('list_framework_categories');
    return rows.map(parseCategoryRow);
  },

  async get(id: string): Promise<Omit<FrameworkCategory, 'frameworks'> | null> {
    const row: FrameworkCategoryRow | null = await invoke('get_framework_category', { id });
    return row ? parseCategoryRow(row) : null;
  },

  async create(name: string, description: string, icon: string): Promise<Omit<FrameworkCategory, 'frameworks'>> {
    const row: FrameworkCategoryRow = await invoke('create_framework_category', { name, description, icon });
    return parseCategoryRow(row);
  },

  async update(id: string, name: string, description: string, icon: string): Promise<Omit<FrameworkCategory, 'frameworks'>> {
    const row: FrameworkCategoryRow = await invoke('update_framework_category', { id, name, description, icon });
    return parseCategoryRow(row);
  },

  async delete(id: string): Promise<void> {
    return await invoke('delete_framework_category', { id });
  },
};

export const frameworkDefsAPI = {
  async list(category?: string): Promise<FrameworkDefinition[]> {
    const rows: FrameworkDefRow[] = await invoke('list_framework_defs', { category: category || null });
    return rows.map(parseFrameworkDef);
  },

  async get(id: string): Promise<FrameworkDefinition | null> {
    const row: FrameworkDefRow | null = await invoke('get_framework_def', { id });
    return row ? parseFrameworkDef(row) : null;
  },

  async create(params: {
    category: string;
    name: string;
    description: string;
    icon: string;
    systemPrompt: string;
    guidingQuestions: string[];
    exampleOutput: string;
    supportsVisuals: boolean;
    visualInstructions?: string;
  }): Promise<FrameworkDefinition> {
    const row: FrameworkDefRow = await invoke('create_framework_def', {
      category: params.category,
      name: params.name,
      description: params.description,
      icon: params.icon,
      systemPrompt: params.systemPrompt,
      guidingQuestions: JSON.stringify(params.guidingQuestions),
      exampleOutput: params.exampleOutput,
      supportsVisuals: params.supportsVisuals,
      visualInstructions: params.visualInstructions || null,
    });
    return parseFrameworkDef(row);
  },

  async update(id: string, params: {
    category?: string;
    name?: string;
    description?: string;
    icon?: string;
    systemPrompt?: string;
    guidingQuestions?: string[];
    exampleOutput?: string;
    supportsVisuals?: boolean;
    visualInstructions?: string | null;
  }): Promise<FrameworkDefinition> {
    const row: FrameworkDefRow = await invoke('update_framework_def', {
      id,
      category: params.category,
      name: params.name,
      description: params.description,
      icon: params.icon,
      systemPrompt: params.systemPrompt,
      guidingQuestions: params.guidingQuestions ? JSON.stringify(params.guidingQuestions) : undefined,
      exampleOutput: params.exampleOutput,
      supportsVisuals: params.supportsVisuals,
      visualInstructions: params.visualInstructions,
    });
    return parseFrameworkDef(row);
  },

  async delete(id: string): Promise<void> {
    return await invoke('delete_framework_def', { id });
  },

  async reset(id: string): Promise<FrameworkDefinition> {
    const row: FrameworkDefRow = await invoke('reset_framework_def', { id });
    return parseFrameworkDef(row);
  },

  async search(query: string): Promise<FrameworkDefinition[]> {
    const rows: FrameworkDefRow[] = await invoke('search_framework_defs', { query });
    return rows.map(parseFrameworkDef);
  },

  async duplicate(id: string, newName: string): Promise<FrameworkDefinition> {
    const row: FrameworkDefRow = await invoke('duplicate_framework_def', { id, newName });
    return parseFrameworkDef(row);
  },
};

interface SavedPromptRow {
  id: string;
  name: string;
  description: string;
  category: string;
  prompt_text: string;
  variables: string;
  framework_id: string | null;
  is_builtin: boolean;
  is_favorite: boolean;
  usage_count: number;
  sort_order: number;
  created_at: number;
  updated_at: number;
}

function parseSavedPrompt(row: SavedPromptRow): SavedPrompt {
  return {
    ...row,
    variables: JSON.parse(row.variables || '[]') as PromptVariable[],
    framework_id: row.framework_id || undefined,
  };
}

export const savedPromptsAPI = {
  async list(category?: string, frameworkId?: string): Promise<SavedPrompt[]> {
    const rows: SavedPromptRow[] = await invoke('list_saved_prompts', {
      category: category || null,
      frameworkId: frameworkId || null,
    });
    return rows.map(parseSavedPrompt);
  },

  async get(id: string): Promise<SavedPrompt | null> {
    const row: SavedPromptRow | null = await invoke('get_saved_prompt', { id });
    return row ? parseSavedPrompt(row) : null;
  },

  async create(params: {
    name: string;
    description: string;
    category: string;
    promptText: string;
    variables: PromptVariable[];
    frameworkId?: string;
  }): Promise<SavedPrompt> {
    const row: SavedPromptRow = await invoke('create_saved_prompt', {
      name: params.name,
      description: params.description,
      category: params.category,
      promptText: params.promptText,
      variables: JSON.stringify(params.variables),
      frameworkId: params.frameworkId || null,
    });
    return parseSavedPrompt(row);
  },

  async update(id: string, params: {
    name?: string;
    description?: string;
    category?: string;
    promptText?: string;
    variables?: PromptVariable[];
    frameworkId?: string | null;
    isFavorite?: boolean;
  }): Promise<SavedPrompt> {
    const row: SavedPromptRow = await invoke('update_saved_prompt', {
      id,
      name: params.name,
      description: params.description,
      category: params.category,
      promptText: params.promptText,
      variables: params.variables ? JSON.stringify(params.variables) : undefined,
      frameworkId: params.frameworkId !== undefined ? params.frameworkId : undefined,
      isFavorite: params.isFavorite,
    });
    return parseSavedPrompt(row);
  },

  async delete(id: string): Promise<void> {
    return await invoke('delete_saved_prompt', { id });
  },

  async search(query: string): Promise<SavedPrompt[]> {
    const rows: SavedPromptRow[] = await invoke('search_saved_prompts', { query });
    return rows.map(parseSavedPrompt);
  },

  async duplicate(id: string, newName: string): Promise<SavedPrompt> {
    const row: SavedPromptRow = await invoke('duplicate_saved_prompt', { id, newName });
    return parseSavedPrompt(row);
  },

  async incrementUsage(id: string): Promise<void> {
    return await invoke('increment_prompt_usage', { id });
  },
};

export const frameworkOutputsAPI = {
  async create(
    projectId: string,
    frameworkId: string,
    category: string,
    name: string,
    userPrompt: string,
    contextDocIds: string[],
    generatedContent: string,
    format: 'markdown' | 'html' = 'markdown'
  ): Promise<FrameworkOutput> {
    return await invoke('create_framework_output', {
      projectId,
      frameworkId,
      category,
      name,
      userPrompt,
      contextDocIds: JSON.stringify(contextDocIds),
      generatedContent,
      format
    });
  },

  async list(projectId: string): Promise<FrameworkOutput[]> {
    return await invoke('list_framework_outputs', { projectId });
  },

  async get(id: string): Promise<FrameworkOutput | null> {
    return await invoke('get_framework_output', { id });
  },

  async update(id: string, name: string, generatedContent: string): Promise<FrameworkOutput> {
    return await invoke('update_framework_output', {
      id,
      name,
      generatedContent
    });
  },

  async delete(id: string): Promise<void> {
    return await invoke('delete_framework_output', { id });
  },

  async generate(
    projectId: string,
    frameworkId: string,
    contextDocIds: string[],
    userPrompt: string
  ): Promise<string> {
    try {
      const apiKey = await settingsAPI.getDecryptedApiKey();
      if (!apiKey) {
        throw new Error('API key not configured');
      }

      const response = await fetch(`${SIDECAR_URL}/generate-framework`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          project_id: projectId,
          framework_id: frameworkId,
          context_doc_ids: contextDocIds,
          user_prompt: userPrompt,
          api_key: apiKey
        })
      });

      if (!response.ok) {
        throw new Error(`Failed to generate framework: ${response.statusText}`);
      }

      const data = await response.json();
      return data.generated_content;
    } catch (error) {
      console.error('Error generating framework:', error);
      throw error;
    }
  }
};

export const marketplaceAPI = {
  async exportFramework(id: string): Promise<string> {
    return await invoke('export_framework', { id });
  },

  async exportFrameworksBatch(ids: string[]): Promise<BatchExportResult[]> {
    return await invoke('export_frameworks_batch', { ids });
  },

  async exportAllFrameworks(): Promise<BatchExportResult[]> {
    return await invoke('export_all_frameworks');
  },

  async previewImportFramework(mdContent: string): Promise<ImportPreview> {
    return await invoke('preview_import_framework', { mdContent });
  },

  async confirmImportFramework(mdContent: string, conflictAction: ConflictAction): Promise<ImportResult> {
    return await invoke('confirm_import_framework', { mdContent, conflictAction });
  },

  async exportPrompt(id: string): Promise<string> {
    return await invoke('export_prompt', { id });
  },

  async exportPromptsBatch(ids: string[]): Promise<BatchExportResult[]> {
    return await invoke('export_prompts_batch', { ids });
  },

  async exportAllPrompts(): Promise<BatchExportResult[]> {
    return await invoke('export_all_prompts');
  },

  async previewImportPrompt(mdContent: string): Promise<ImportPreview> {
    return await invoke('preview_import_prompt', { mdContent });
  },

  async confirmImportPrompt(mdContent: string, conflictAction: ConflictAction): Promise<ImportResult> {
    return await invoke('confirm_import_prompt', { mdContent, conflictAction });
  },
};

export const workflowsAPI = {
  async create(projectId: string, name: string, description: string, stepsJson: string): Promise<Workflow> {
    return await invoke('create_workflow', { projectId, name, description, stepsJson });
  },

  async list(projectId: string): Promise<Workflow[]> {
    return await invoke('list_workflows', { projectId });
  },

  async get(id: string): Promise<Workflow> {
    return await invoke('get_workflow', { id });
  },

  async update(id: string, name: string, description: string, stepsJson: string): Promise<Workflow> {
    return await invoke('update_workflow', { id, name, description, stepsJson });
  },

  async delete(id: string): Promise<void> {
    return await invoke('delete_workflow', { id });
  },

  async duplicate(id: string, newName: string, projectId: string): Promise<Workflow> {
    return await invoke('duplicate_workflow', { id, newName, projectId });
  },

  async createRun(workflowId: string, projectId: string): Promise<WorkflowRun> {
    return await invoke('create_workflow_run', { workflowId, projectId });
  },

  async getRun(id: string): Promise<WorkflowRun> {
    return await invoke('get_workflow_run', { id });
  },

  async listRuns(workflowId: string): Promise<WorkflowRun[]> {
    return await invoke('list_workflow_runs', { workflowId });
  },

  async updateRunStatus(id: string, status: string, completedAt?: number): Promise<void> {
    return await invoke('update_workflow_run_status', { id, status, completedAt });
  },

  async deleteRun(id: string): Promise<void> {
    return await invoke('delete_workflow_run', { id });
  },

  async createRunStep(runId: string, stepIndex: number, frameworkId: string, inputPrompt?: string): Promise<WorkflowRunStep> {
    return await invoke('create_workflow_run_step', { runId, stepIndex, frameworkId, inputPrompt });
  },

  async updateRunStep(id: string, status: string, outputContent?: string, outputId?: string, error?: string): Promise<void> {
    return await invoke('update_workflow_run_step', { id, status, outputContent, outputId, error });
  },

  async listRunSteps(runId: string): Promise<WorkflowRunStep[]> {
    return await invoke('list_workflow_run_steps', { runId });
  },

  async getRunStep(id: string): Promise<WorkflowRunStep> {
    return await invoke('get_workflow_run_step', { id });
  },
};

export const insightsAPI = {
  async list(projectId: string): Promise<ProjectInsight[]> {
    return await invoke('list_project_insights', { projectId });
  },

  async dismiss(id: string): Promise<void> {
    return await invoke('dismiss_insight', { id });
  },

  async save(projectId: string, insightsJson: string): Promise<void> {
    return await invoke('save_insights', { projectId, insightsJson });
  },

  async clear(projectId: string): Promise<void> {
    return await invoke('clear_project_insights', { projectId });
  },
};

export const gitAPI = {
  async initRepo(projectId: string): Promise<void> {
    return await invoke('init_project_repo', { projectId });
  },

  async commitOutput(projectId: string, outputId: string, name: string, content: string, message: string): Promise<void> {
    return await invoke('commit_output', { projectId, outputId, name, content, message });
  },

  async listOutputCommits(projectId: string, outputId: string): Promise<CommitInfo[]> {
    return await invoke('list_output_commits', { projectId, outputId });
  },

  async getCommitDiff(projectId: string, commitOid: string): Promise<string> {
    return await invoke('get_commit_diff', { projectId, commitOid });
  },

  async getOutputAtCommit(projectId: string, outputId: string, commitOid: string): Promise<string> {
    return await invoke('get_output_at_commit', { projectId, outputId, commitOid });
  },

  async rollbackOutput(projectId: string, outputId: string, commitOid: string): Promise<string> {
    return await invoke('rollback_output', { projectId, outputId, commitOid });
  },
};

export const integrationsAPI = {
  async testJiraConnection(): Promise<boolean> {
    return await invoke('test_jira_connection');
  },

  async listJiraProjects(): Promise<JiraProject[]> {
    return await invoke('list_jira_projects');
  },

  async exportToJira(outputId: string, projectKey: string, issueType: string, summary: string): Promise<JiraExportResult> {
    return await invoke('export_to_jira', { outputId, projectKey, issueType, summary });
  },

  async testNotionConnection(): Promise<boolean> {
    return await invoke('test_notion_connection');
  },

  async searchNotionPages(query: string): Promise<NotionPage[]> {
    return await invoke('search_notion_pages', { query });
  },

  async exportToNotion(outputId: string, parentPageId: string, title: string): Promise<NotionExportResult> {
    return await invoke('export_to_notion', { outputId, parentPageId, title });
  },
};
